import React from 'react';
import ReactDOM from 'react-dom';
import App from './components/app';
import PropTypes from "prop-types";
import Row from "./components/row/row";

ReactDOM.render(<App />,
    document.getElementById('root'));

/*Как работает fetch
Чтобы получить данные с сервера, нужно выполнить два вызова (каждый вернет Promise):
res = await fetch(url);
body = await res.json();

Кроме .json() есть другие функции для других типов ответа: arrayBuffer(), blob(), text(), formData()

//
fetch('https://swapi.co/api/people/1/')
    .then((res) => {
        return res.json(); //получаем результат, апи
    })
    .then((body) => {
        console.log(body); //вытаскиваем тело из результата
    });

//эквивалентный код, используя async await
const getResource = async (url) => { //асинхронная функция, принмает url, то что мы хотим получить
    const res = await fetch(url);//получаем ответ сервера, ждем пока результат промиса не будет доступен, как только он станет доступен мы запишем его в переменную res
    const body = await res.json();//res.json возвращает промис, await будет ждать, пока результат промиса не будет достпуен и затем результат будет записан в body
    return body;
};

getResource('https://swapi.co/api/people/1/')
    .then ((body) => { //как только ресорс будет доступен мы получаем тело и печатаем его в консоль
        console.log(body);
    });
*/

/*обработка ошибок в Fetch
Fetch отклоняет (reject) Promise, только если произошла ошибка сети (сервер недоступен).
Чтобы проверить код результата, можно использовать result.status
result.ok содержит true, если result.status содержит один из ОК-статусов (200-299).
 */

/*API-клиент
Код, который работает с сетью лучше изолировать в отдельный класс-сервис.
Компоненты не должны знать откуда именно берутся данные.
Такой подход упростит тестирование и поддержку кода, который работает с API. */

/*Компоненты StarDB
Начинать разработку Реакт приложения удобно с создания разметки компонентов.
Такие компоненты ничего не делают, они просто отображают данные.
В финальной версии приложения "разбивка" на компоненты может измениться, но такой шаблон на Реакт - хорошее начало.
 */

/*Как отобразить данные из API
В конструкторе компонента вызываем сервис, который получит данные.
В then() обновляем состояние компонента
 */

/*
  updatePlanet() {
    const id = Math.floor(Math.random()*25) + 2; //(мат.рэндом возвращает значение от 0 до 1 случайное * 25 (первые 25 планет)//math.floor округляет вниз до ближайщего целого) + 2 прибавляем два
    this.swapiService
        .getPlanet(id) //используем айди когда получаем планету
        .then((planet) => { //когда данные будут доступны мы скопируем значение из той планеты, которую мы получили от свапиКо в наш стейт
            this.setState({ //используем сетСтейт которая просто передает объект, поскольку это наш стейт не зависит от предидущего стейта
                id, //устанавливаем этот айди в стэйт
                name: planet.name, // благодаря этому блоку кода мы можем контролировать какие данные мы получаем
                population: planet.population,
                rotationPeriod: planet.rotation_period,
                diameter: planet.diameter
            });
        });
  }
 */

/*Трансформация данных API
Изолируйте код, который обрабатывает данные.
Отделяйте модель данных API от модели данных приложения.
Такая практика чаще применяется для крупных проектов со сложными моделями данных, которые могут изменяться.
 */

/*Создаем индикатор загрузки
Хорошее приложение не отображает элементы для которых нет данных.
Мы создали спиннер, использовав CSS код с:
https://loading.io - сайт который позволяет создать лоадеры и импортировать их затем в свое приложение
 */

/*Логика индикатора загрузки
"Состояние" загрузки можно хранить в state.
В зависимости от этого состояния рендерим индикатор загрузки или содержимое компонента (уже с данными).
Старайтесь разделять логику и рендеринг.
React.Fragment позволяет группировать элементы не создавая лишних DOM объектов.

Фрагмент позовляет обернуть несколько элементов jsx не создавая новых ДОМ элементов. Реакт.Фрагмент элемент-обертка для того чтобы сгруппировать другие элементы, поскольку функцией рендер мы можем вернуть только один элемент.
        <React.Fragment>
            <img />
            <div></div>
        </React.Fragment>
 */

/*Обработка ошибок сети в компоненте
В state добавим поле, где будем хранить флаг: нужно ли отобразить ошибку.
В зависимости от этого флага, отображаем ошибку, или нормальное содержимое компонента.
Будьте внимательны с async/await - код с await может выбросить Error.
 */

/*Работа с API - выводы
1. Реакт ничего не знает о работе с сервером - это задача других библиотек.
2. Сетевой код следует изолировать от кода компонентов.
3. Если необходимо, трансформируйте данные до того, как их получит компонент.
4. Обрабатывайте состояния "загрузка" и "ошибка".
5. Разделяйте ответственность компонентов: логику и рендеринг.
 */

/*Жизненный цикл Реакт компонентов
Компонентам нужно выполнять код в определенные моменты своей жизни.
К примеру, перед тем, как компонент будет удален, необходимо очистить ресурсы.
В React для этого есть механизм - методы жизненного цикла (lifecycle hooks).
 */

/*Методы жизненного цикла
Цикл жизни реакт компонента (Life cycle):
1.Сперва компонент создается через конструктор, вызывается функция конструктор.
Затем Реакт вызывает функцию рендер, функция рендер возвращает дерево Реакт компонентов, эти элементы превращаются в ДОМ элементы, которые затем добавляются к ДОМ дереву на странице.
3. Затем компонент может некоторое время обновляться. Или компонент получает новое свойство и тогда реакту снова придется вызвать функцию рендер для того чтобы получить новое представление элементов.
Либо в результате какого-нибудь события компонент вызывает setState и это приводит к такому же эффекту - вызывается функция рендер, полученное дерево jsx элементов превращается в ДОМ элементы, ДОМ дерево обновляется.
4. В какой-то момент компонент становится больше не нужен, он больше не отображается на странице, тогда созданные для компонента ДОМ ноды удаляются со страницы и компонент уничтожается.

На каждом этапе жизненного цикла, Реакт вызывает одну из специальных функций компонента. Эти функции называются lifecycle hooks.
Этапы:
1. Mounting (когда компонент создается и первый раз отображается на странице)
constructor() => render() => componentDidMount() - компонент "поключен" (DOM элементов уже на странице)
2. Updates (получать обновления)
New props или setState => render() => componentDidUpdate(prevProps, prevState) - компонент обновился
3. Unmounting (когда компонент становится не нужен и удалится с нашей страницы)
componentWillUnmount() - компонент будет удален (но DOM еще на странице)
4. Error (получает ошибку, которая не была поймана раньше)
componentDidCatch() - когда в компоненте (или в его child-компонентах) произошла ошибка
На каждом этапе есть несколько функций жизненного цикла React компонента. Сверху не полный список методов жизненного цикла, а примеры. Другие используются редко и в специфических случаях.
 */

/*componentDidMount()
componentDidMount() - компонент "подключен" (DOM элементы уже на странице).
Используя для инициализации (получение данных, работа с DOM, и т.д.).
Не используйте конструктор для кода, который создает побочные эффекты.

Этот метод вызывается после того когда компонент первый раз удачно инициализировался и отрисовался на странице. Этот метод это самое подходящее место для того чтобы проводить первоначальную инициализизацию компонента или делать запросы к API и начинать асинхронное получение данных. Инициализацию компонента которая зависит от внешних источников данных лучше проводить когда componentDidMount.
Когда этот метод вызван, это означает что DOM элементы уже гарантированно находятся на странице и они проинициализированы. Нельзя вызывать setState до componentDidMount. При работе с компонентом который работает со сторонними библиотеками и которые работают непосредственно с ДОМ, в этом месте мы можем быть уверены что ДОМ уже создан и те библиотеки могут начать свою инициализацию, используя уже готовые элементы ДОМ дерева.
В большей части случаев лучше не использовать конструктор в компонентах-классах. А инициализировать необходимые поля прямо в теле класса, когда такая инициализация не создает никаких сайд эффектов или побочных эффектов, а когда нужно вызвать API или создать интервал, лучше использовать метод componentDidMount.
 */

/*componentDidMount() на практике
componentDidMount() - хорошее место, для того, чтобы получать данные
 */

/*componentDidUpdate()
componentDidUpdate() - вызывается после того, как компонент обновился.
Компонент обновляется после того, как получает новые свойства или state.
Этот метод вызывается после render() - в нем можно, к примеру, запрашивать новые данные для обновленных свойств.

Этот метод вызывается сразу после того как компонент обновился в результате того что он получил новые свойства или он вызвал сетСтэйт и получил новый стейт. Первая инициализация компонента, то есть первый конструктор, рендер и компонентДидМаунт не считаются обновлением, поэтому в первый раз componentDidUpdate() не будет вызываться.
Он будет вызываться только для обновленных свойств, то есть когда компонент сначала получил одни свойства, а зате эти свойства были изменены, то же верно и для стейта.
Этот метод хорошо использовать тогда, когда компоненту нужно обновляться в результате обновления свойств, то есть он не напрямую зависит от свойств, а ему нужно что-нибудь еще сделать
componentDidUpdate принимает два аргумента, prevProps и prevState
Когда эта функция исполняется, стэйт уже обновлен, уже рендер сработал и стэйт уже имеет новое состояние. И prevProps и prevState это предыдущие версии props и state, которые мы можем использовать для того чтобы строить логику в componentDidUpdate
 */

/*componentDidUpdate() на практике
Мы использовали этот метод, чтобы подгрузить новые данные, когда personId изменился.
Очень важноЖ если в этом методе может изменяться state - обязательно проверять, какое именно свойство изменилось.
...иначен компонент рискует уйти в "вечный цикл" обновления.

Функция из жизненного цикла, которая вызывается сразу после того как компонент  обновился и отрендерился. componentDidUpdate принимает предидущее пропсы и состояние. И делается это чтобы сравнить прошлое состояние и текущее и решить нужно нам что-то делать или нет.
Если мы будем обновлять компонент сразу после того как он обновился, мы закончим с бесконечным циклом.
И внутри этой функции мы можем писать любую логику, которая должна реагировать на изменения свойст или измнение стейта компонента.
  componentDidUpdate(prevProps) { //получаем prevProps //обязательно обернуть код в условие, надо сравнить. Потому что иначе setState сам по себе приведет к тому компонент обновится и Реакт вызовет componentDidUpdate, поскольку стейт обновился и если здесь не будет условия, начнется цикл обновления персонажа и заново вызовется все по бесконечному циклу
    if (this.props.personId !=== prevProps.personId) {
      this.updatePerson();
    }
  }
 */

/* componentWillUnmount()
componentWillUnmount() - компонент будет удален.
Используется для очистки ресурсов (таймеры, интервалы, запросы к серверу).
В момент вызова ДОМ все еще находится настранице.

Полностью симметричен методу componentDidMount и он вызывается перед тем, как компонент окончательно очистится. В тот момет когда мы вызываем этот метод ДОМ дерево компонента все еще находится на странице. Этот метод используется для того чтобы очистить те ресурсы, с которыми работал компонент, если такая очистка нужна.
К примеру, если у нас запущен setInterval, то этот метод самое хорошо место для того чтобы его очистить. В этом методе можно отменять текущие запросы к серверу или отписываться от веб сокетов.
Кроме того если компонент работает со сторонней библиотекой и этой библиотеке тоже нужно сделать свою очистку, перед тем как ДОМ удалится, этот метод это самое лучшее место для того чтобы записать туда этот код.
На практике этот метод используется намного реже чем componentDidMount, поскольку в вебе не так много компонентов, которые создают ресурсы, которые затем нужно очищать.
 */

/*componentDidCatch()
componentDidCatch() - отлавливает ошибки, которые произошли в методах жизненного цикла ниже по иерархии.
Принцип работы похож на try/catch - ошибку отлавливает ближайший блок.
Не обрабатываются ошибки в event listener-ax и в асинхронном коде (запросы к серверу и т.п.).

Его задачей является обработка непойманных ошибок в других методах жизненного цикла React компонента, в функциях, setState, render, componentDidUpdate, componentDidMount и всех остальных методах. componentDidCatch отлавливает ошибки из функций, которые отвечают за корректный рендеринг компонента, за корректное состояние компонента.
Компоненты, которые содержат componentDidCatch() называются error boundaries, поскольку они ловят ошибки ниже себя по иерархии и ограничивают область действия этих ошибок. То как работает componentDidCatch() похоже на работу tryCatch в js, если в js происходит ошибка то ее отлавливает ближайший tryCatch.
По аналогии с tryCatch, если в componentDidCatch ниже по иерархии, когда componentDidCatch будет обрабатывать эту ошибку в нем произойдет exception, то этот exception пойдет выше в следующий componentDidCatch.
componentDidCatch() работает только с ошибками в методах жизненного цикла, то есть в методах render, componentDidMount, componentDidUpdate и т.д., то есть с теми ошибками, которые непосредственно влияют на состояние компонента и на рендеринг. И ошибки в eventListener-ax, например в той функцию которую передаем в onClick, они не будут обрабатываться componentDidCatch.
Точно так же ошибки не будут обрабатываться в асинхронных колбэках, даже если асинхронный вызов был инициирован в методах жизненного цикла. К примеру componentDidMount мы часто запрашиваем данные на сервер и если сервер вернул нам 404 и мы отклонили промис, то эта ошибка не будет обрабатываться componentDidCatch.
componentDidCatch это не замена стандартным проверкам, это не замена валидации данных. Роль этого метода - ловить те ошибки, которые мы действительно не предвидели во время разработки. То есть этот метод в идеале вообще не должен срабатывать.
 */

/*componentDidCatch() на практике
Чтобы определить границы ошибок, нужны компоненты, которые будут разделять независимые блоки приложения.
componentDidCatch() принимает два аргумента - error и info с дополнительной информацией об источнике ошибок.

componentDidCatch(error, info) принимает еще два параметра, error - та ошибка, которая привела к срабатыванию метода, info - детали того в каком компоненте эта ошибка произошла.
*/

/*Паттерны React
В этом разделе мы рассмотрим основные паттерны работы с React кодом.
Наша цель - научиться переиспользовать аспекты поведения React компонентов и разделять ответственность компонентов.
Большинство паттернов основано на чистом JavaScript и здравом смысле.
 */

/*Использование функций
Функции, которые мы передаем компоненту могут быть не только обработчиками событий.
Функция, к примеру, может инкапсулировать получение данных (тогда компонент становится независимым от источника данных).
 */

/*Render-функции
Паттерн React - в компонент передается функция, которая рендерит часть компонента (или вест компонент).
<Card
renderBody={() => <p>hello</p>}/>
Такая функция обычно возвращает строку или React элемент.

Render-функция - это паттерн реакта, когда мы передаем в реакт компонент функцию, которая занимается рендерингом части этого компонента или вообще всего компонента
 */

/*Свойства-элементы
В качестве значения свойства можно передавать React элемент.
<Card title={<h1>Hi</h1>}/>
Так можно создавать элементы-"контейнеры".
... или элементы, которые умеют выбирать, что рендерить в зависимости от условия (загрузка, ошибка и т.п.)
 */

/*
                <div className="row mb2">
                    <div className="col-md-6">
                        <ItemList
                            onItemSelected={this.onPersonSelected}
                            getData={this.swapiService.getAllPlanets}
                            renderItem={(item) => (<span>{item.name} <button>!</button></span>
                            )}/>
                    </div>
                    <div className="col-md-6">
                        <PersonDetails personId={this.state.selectedPerson}/>
                    </div>
                </div>

                <div className="row mb2">
                    <div className="col-md-6">
                        <ItemList
                            onItemSelected={this.onPersonSelected}
                            getData={this.swapiService.getAllStarships}
                            renderItem={(item) => item.name}/>
                    </div>
                    <div className="col-md-6">
                        <PersonDetails personId={this.state.selectedPerson}/>
                    </div>
                </div>
 */

/*Children
Компоненту можно передавать одно из свойств, поместив его в тело элемента
<Card>How are you</Card>
Это свойство доступно через props.children
Поддерживает любые типы данных: элементы, функции, объекты и другие.
 */

/*Рефакторинг компонента
Мы вынесли детали получения данных и адреса картинки в отдельные функции.
В таком виде компонент может работать с разными объектами.
Осталось решить, как сконфигурировать, какие именно данные будет отображать компонент.
 */

/* Работа c props.children
Компонент может решать, как именно использовать children
Функция React.Children.map() упрощает обработку props.children.
Child элементы можно заменять, оборачивать в другие компоненты или скрывать (если вернуть null)
 */

/*Клонирование элементов
React элементы нельзя изменять (они считаются immutable)
... но можно создавать модифицированные копии при помощи React.cloneElement().
К примеру, элементам можно добавлять новые свойства.
 */

/*079 Компоненты высшего порядка (HOC)
Функция, которая создает компоненты и оборачивает существующие
const hoc = (Wrapped) => {
    return class wxtends Component {
        render() {
            return <Wrapped {...this.props} />
        }
    }
}
const MyWrappedComponent = hoc(InnerComponent);
 */

/*080 Рефакторинг компонентов
Обратная сторона "гибкости" компонентов это громоздкая конфигурация.
Кoд будет более читабельным, если вынести детали конфигурации в отдельные компоненты.
Для этого можно использовать НОС (компоненты высшего порядка) или просто написать компонент-обертку вручную.
 */

/*081 Композиция компонентов высшего порядка
Композиция - примменение одной функции к результату другой: f(g(x))
Компоненты высшего порядка это обычные функции, который возвращают компоненты. Композиция работает и для них.
Так мы можем применять несколько "эффектов" НОС.
НОС - Higher Order Component.

Композиция hoc позволяет применить эффекты нескольких компонентов поверх того компонента, который мы хотим обернуть.
в каждом компоненте ниже мы берем за основу ItemList, затем он проходит через функцию withChildFunction, это создает новый компонент у которого уже установлена функция для рендера child-элементов этого списка. Затем этот самый компонент, который мы создали (мы даже не присваивали ему имя или не присваивали его константе) мы передаем дальше в функцию withData и эта функция в свою очередь оборачивает этот компонент в намного более сложный компонент, который занимается получением данных и обработкой ошибок.
const PersonList = withData( //используем hoc withData для создания: Это ItemList, у которого будут данные из функции getAllPeople
                      withChildFunction(ItemList, renderName), //эта функция возвращает компонент, первым аргументом передается сюда компонент, который мы будем оборачивать (ItemList). в качестве второго аргумента мы передадим функцию, которая станет рендер функцией в ItemList-е. То есть это ItemList с рендер функцией. Мы передаем сюда ее вместо ItemList, теперь для этого компонента всегда установлена рендер-функция. И поэтому можно в app.js -List использовать без рендер-функции (она уже встроена в эти компоненты).
                      getAllPeople);
 */

/*082 Контекст
Контекст нужен для того, чтобы решить проблему "глобальных" данных.
Вместо того, чтобы передавать props через все слои приложения, данные можно передавать через контекст.
 С помощью контекста мы сможем сделать так, чтобы компоненты не создавали объекты сервиса, а получали его.

 const { //эта функция возвращает пару - Provider и Consumer, мы их сразу переименовываем
    Provider: SwapiServiceProvider,
    Consumer: SwapiServiceConsumer
} = React.createContext(); //Эта функция может принимать опциональный аргумент, это значение по умолчанию, если наш Consumer не сможет найти никакого Provider, то по он будет использоваться значение, которое мы сюда можем передать. В нашем приложении всегда присутствует значение, поэтому мы сюда ничего не передаем.
*/

/*083 Использование Context API
создадим конекст
const { Provider, Consumer } = React.createService()

<Provider value={someValue}
    ..// провайдер оборачивает часть приложения
</Provider>

<Consumer> {
    (someValue) => <MyComponent data={someValue} />
} </Consumer>


const PersonDetails = ({ itemId }) => {

  return ( //оборачиваем компоненты, которым нужен сервис в SwapiServiceConsumer// Consumer принимает в качестве тела функцию и эта функция будет принимать swapiService (именно тот swapiService, который мы установили в иерархии выше в компоненте app.js - value={this.swapiService}). И теперь здесь мы можем использовать swapiService для того чтобы передать нужное значение в ItemDetails //прямо при объявлении достаем из swapiService getPerson, getPersonImage// Теперь ItemDetails использует swapiService из конекста
    <SwapiServiceConsumer>
        {
            ( {getPerson, getPersonImage} ) => {
                return (
                    <ItemDetails
                        itemId={itemId}
                        getData={getPerson}
                        getImageUrl={getPersonImage} >

                        <Record field="gender" label="Gender" />
                        <Record field="eyeColor" label="Eye Color" />
                    </ItemDetails>
                );
            }
        }
    </SwapiServiceConsumer>
  );
};
 */

/* 084 Использование HOC для работы с контекстом
Обязанность получать данные из контекста можно вынести в компонент высшего порядка
const withValueFromContext = (Wrapped) => {
    return (
        <Consumer>
            { (value) => <Wrapped value={value} /> }
        </Consumer>


const PersonDetails = ({ itemId, swapiService }) => { //благодаря тому что мы обернули PersonDetails в withSwapiService, у нас в пропс есть swapiService и мы можем его здесь получить и мы можем рассчитывать на то что оно всегда будет
    const { getPerson, getPersonImage } = swapiService; //достаем getPerson, getPersonImage из swapiService
    return (
        <ItemDetails
            itemId={itemId}
            getData={getPerson}
            getImageUrl={getPersonImage} >

            <Record field="gender" label="Gender" />
            <Record field="eyeColor" label="Eye Color" />
        </ItemDetails>
    );
};

export default withSwapiService(PersonDetails); //оборачиваем PersonDetails в withSwapiService. Это означает что когда PersonDetails будет вызываться, withSwapiService позаботиться о том, чтобы в свойствах этого компонента (в пропс) обязательно было свойство swapiService
//consumer теперь находится в withSwapiService. Код нашего основного компонента не изменился, но теперь перед тем как его экспортировать мы просто обернули его в дополнительный компонент hoc
 */

/* 085 Трансформация props в компонентах высшего порядка
НОС может переобразовывать свойства перед тем, как передавать их компоненту.
 Например, изменять их имена и выбирать, какие именно свойства нужно передать.
 При помощи дополнительной функции (mapMethodsToProps) можно определять это поведение для каждого компонента.
 */

/*086 Обновление контекста
Значение в контексте можно обновлять, как любое другое свойство компонента.
Компоненты должны поддерживать изменение нужных свойств.
componentDidUpdate() - функция в которой можно проверить, какие свойства изменились.
 */

/*087-88 Рефакторинг
Старый код в item-lists
//в каждом компоненте ниже мы берем за основу ItemList, затем он проходит через функцию withChildFunction, это создает новый компонент у которого уже установлена функция для рендера child-элементов этого списка. Затем этот самый компонент, который мы создали (мы даже не присваивали ему имя или не присваивали его константе) мы передаем дальше в функцию withData и эта функция в свою очередь оборачивает этот компонент в намного более сложный компонент, который занимается получением данных и обработкой ошибок.
const PersonList = withSwapiService( // вызываем withSwapiService
                      withData( // передаем ему withData, затем withChildFunction - Это ItemList, у которого будут данные из функции getAllPeople// getAllPeople мы не получаем в явном виде, а получаем из контекста
                      withChildFunction(ItemList, renderName)),  //эта функция возвращает компонент, первым аргументом передается сюда компонент, который мы будем оборачивать (ItemList). в качестве второго аргумента мы передадим функцию, которая станет рендер функцией в ItemList-е. То есть это ItemList с рендер функцией. Мы передаем сюда ее вместо ItemList, теперь для этого компонента всегда установлена рендер-функция. И поэтому можно в app.js -List использовать без рендер-функции (она уже встроена в эти компоненты).
                      mapPersonMethodsToProps); //в качестве второго аргумента передаем туда mapMethodsToProps


Новый:
//в каждом компоненте ниже мы берем за основу ItemList, затем он проходит через функцию withChildFunction, это создает новый компонент у которого уже установлена функция для рендера child-элементов этого списка. Затем этот самый компонент, который мы создали (мы даже не присваивали ему имя или не присваивали его константе) мы передаем дальше в функцию withData и эта функция в свою очередь оборачивает этот компонент в намного более сложный компонент, который занимается получением данных и обработкой ошибок.
const PersonList = withSwapiService(mapPersonMethodsToProps)( // вызываем withSwapiService, он принимает сперва в качестве аргумента mapPersonMethodsToProps
                      withData( // и затем функция, которую мы возвращаем вызывается на самом компоненте, который мы получим из функции withData // withChildFunction - Это ItemList, у которого будут данные из функции getAllPeople// getAllPeople мы не получаем в явном виде, а получаем из контекста
                        withChildFunction(renderName)(  //withChildFunction получает renderName
                            ItemList)));   //затем оборачивает в компонент высшего порядка
//withSwapiService, который сконфигурирован с mapPersonMethodsToProps оборачивает withData, оборачивает withChildFunction, оборачивает ItemList. Код читается последовательно слева направо

Техника, которую мы использовали называется "частично примененные функции" (partially applied functions)
const add = (a) => (b) => a + b //пример такой функции
Такие функции принимают часть аргументов и возвращают новые функции - с меньшим количеством аргументов.
 */

/*089 Функция compose()
Реализует композицию в виде функции

compose = (...funcs) => (comp) => {
    return funcs.reduceRight(
        (wrapped, f) => f(wrapped), comp);
};

const MyComp = compose(
                   withService,
                   withData,
                   withChild(renderName)
                )(SimpleComponent);

//в каждом компоненте ниже мы берем за основу ItemList, затем он проходит через функцию withChildFunction, это создает новый компонент у которого уже установлена функция для рендера child-элементов этого списка. Затем этот самый компонент, который мы создали (мы даже не присваивали ему имя или не присваивали его константе) мы передаем дальше в функцию withData и эта функция в свою очередь оборачивает этот компонент в намного более сложный компонент, который занимается получением данных и обработкой ошибок.
const PersonList = compose(
                        withSwapiService(mapPersonMethodsToProps), // вызываем withSwapiService, он принимает сперва в качестве аргумента mapPersonMethodsToProps
                        withData, // и затем функция, которую мы возвращаем вызывается на самом компоненте, который мы получим из функции withData // withChildFunction - Это ItemList, у которого будут данные из функции getAllPeople// getAllPeople мы не получаем в явном виде, а получаем из контекста
                        withChildFunction(renderName)  //withChildFunction получает renderName
                    )(ItemList);   //затем оборачивает в компонент высшего порядка
 */

/*090 Свойство defaultProps
Позволяет установить значения по-умолчанию для свойств
const Comp = ({ name }) => (<p>{name}</p>);
Comp.defaultProps = {
    name: 'Bob'
}

//отрендерит Hi Bob
<Comp />
*/

/*091 Свойство propTypes
Позволяет проверить значения свойств (props), которые получает компонент.
const Comp = ({ name }) => (<p>{name}</p>);
Comp.propTypes = {
    name: (props, propName, compName) => {...}
}
Проверка срабатывает после defaultProps.
Функция-валидатор возвращает null или объект Error.

  static propTypes = {
      updateInterval: (props, propName, componentName) => { //если мы хотим проверить значение updateInterval, то мы сюда устанавливаем в качестве ключа updateInterval, а в качестве значения мы установим сюда функцию, которая будет проверять значение updateInterval у компонента. Эта функция принимает 3 аргумента: props, propName и componentName. props - это весь объект свойств с которым мы работаем. propName - имя того свойства, которого мы сейчас проводим валидацию (сейчас updateInterval). componentName - название компонента для которого мы сейчас проводим валидацию
        const value = props[propName]; //получаем значение которое нам передал пользователь в updateInterval

        if (typeof value === 'number' && !isNaN(value)) { //если это значение цифровое и не NaN
            return null; //если все проверки прошли успешно - возвращаем значение null
        }

        return new TypeError(`${componentName}: ${propName} must be number`); //но если проверки не прошли успешно - возвращаем (а не выбрасываем) ошибку
      }
  };
 */

/*092 NPM - установка дополнительных пакетов
Чтобы установить новый пакет:
npm install prop-types
NPM - стандартный менеджер пакетов в Node.js
NPM используется не только для Node.js пакетов, но и для front-end разработки
 */

/*093 Библиотеки prop-types
Библиотека prop-types - набор стандартных функций-валидаторов
MyComponent.propTypes = {
    'some_number': PropTypes.number
    'some_mandatory_number': PropTypes.number.isRequired
}
Есть и другие библиотеки, с дополнительными валидаторами. К примеру, airbnb-prop-types.

  static propTypes = {
      updateInterval: PropTypes.number //PropTypes.number.isRequired - если обязательное свойство
  };
Как правило те свойства у которых есть значения по умолчанию не обязательны

ItemList.propTypes = {
    onItemSelected: PropTypes.func, //onItemSelected - это опциональная функция
    data: PropTypes.arrayOf(PropTypes.object).isRequired, //массив любых объектов, в скобках передаем какого типа наш массив. isRequired поскольку наш массив расчитывает что ему передадут данные
    children: PropTypes.func.isRequired //должно обязательно быть функцией
};

Row.propTypes = {   //так описали, поскольку это компонент-функция
    left: PropTypes.node, //PropTypes.node проверяет что соответствующий проперти это что-то, что можно отрендерить в jsx. В PropTypes описан еще один тип, который называется PropTypes.element, но он намного более узкий, он принимает только реакт элементы, хотя наш компонент может работать отлично и со строками и числами, поэтому мы здесь использовали node
    right: PropTypes.node
};

пример - объект с определенной структурой - компонент, который должен получать в качестве свойства объект user, у которого есть name и role
My.Comp.propTypes = {
    user: PropTypes.shape({ //shape обозначает что мы ожидаем объект с какой-то определенной формой и эту форму мы описываем станадартными средствами PropTypes
        name: PropTypes.string, //name это PropTypes.string
        role: PropTypes.oneOf(['user', 'admin']) //role может иметь одно из двух значений: user или админ. Мы передаем сюда массив возможных значений
        })
}
 */

/*094 Что такое роутинг
Роутинг - переключение между виртуальными "страницами" UI приложения.
Роутинг нужен, чтобы упростить структуру приложения и организовать навигацию.
В Single Page Application страница, на самом деле, одна и она не перезагружается
 */

/*095 Основы react-router
Пример роутинга для приложения:
<Router>
    <Route path="/blog" component={Blog} />
    <Route path="/about" component={About} />
    <Route path="/shop" component={Shop} />
</Router>

React Router это не часть React. Есть и другие библиотеки для роутинга (к примеру, UI-Router)
 */

/*096 Link
Чтобы переключать страницы, используйте компонент Link из react-router
<Link to="/people">People</Link>
Link работает почти как тег <a>, но он не перезагружает страницу (и при этом обновляет URL в адресной строке)
 */

/*097 Как работает Route
В Route можно передать render функцию
<Route path="/hi" render={() => <p>Hi</p>} />
Route работает как фильтр - сравнивая path с текущим адресом он решает, отрисовывать содержимое или нет.
Параметр exact говорит, что нужно использовать точное совпадение (а не "path является частью адреса").
 */

/*098 Динамические пути
>В Route можно передать параметры:
<Route path="/people/:id"
    render={({match}) => <p>{match.params.id}</p> />

>:id может быть любой строкой, которая идет после /people/
>Если не установить exact, то путь /people будет срабатывать всегда, когда срабатывает /people/:id

<Route path="/starships/:id"
                            render={({ match //В рендер функцию React Router передаст объект с 3 спец. параметрами (объектами, которые используются для роутинга): 1) match - детали о том как именно path="/starships/:id" совпал с тем конкретным адресом, который находится сейчас в строке браузера и вчастности в объекте match есть те параметры что мы передали в этот объект. 2) location содержит детальную информацию о текущем состоянии Router-a о текущем положении у текущей страницы, которая отображается 3)history - для того чтобы программно например перейти на другую страничку. это тот API который внутри себя использует Router для того чтобы организовать переходы между страницами//}) => {
    const { id } = match.params //берем айди из из значения url из match.params//;
    return <StarshipDetails itemId={id} //передаем айди в StarshipDetails для отображения на отдельной странице// />
}}/>
 */

/*099 withRouter
>withRouter это компонент высшего порядка, он передает компоненту объекты react router:
const MyComponent = ({ match, location, history }) => {
    return (
        <Button
            onClick={() => history.push('/new/path')}
        > Click Me </Button>);
};

export default withRouter(MyComponent)
>
import { withRouter } from 'react-router-dom'; //импортируем hoc из react-router-dom

const StarshipsPage = ({ history }) => { //из 3 объектов реакт роутер нам нужен только history и мы сразу достаем его из props
    return (
        <StarshipList
            onItemSelected={(itemId) => { //получаем itemId
              history.push(`/starships/${itemId}`) //пользователь перейдет на новую страницу, адрес которой будет `/starships/${itemId}` для этого используем метод history.push. history это объект, который работает с историей браузера и когда мы говорим history.push мы как-бы добавляем новый элемент в историю браузера, соответственно переводим браузер на новую страницу
            }} />
    );
};

export default withRouter(StarshipsPage); //оборачиваем, передаем StarshipsPage в hoc withRouter, благодаря чему withRouter передаст в StarshipsPage три объекта, которые использует React Router: match, location, history
 */

/*100 Относительные пути
В react-router можно использовать относительные пути.
history.push('/person'); //абослютный путь
history.push('person'); //относительный путь
>Закрывающий слеш - очень важен
history.push('person');
//текущий адес - /site/catalog/
//результат - /site/catalog/person

//текущий адес - /site/catalog (без слеша)
//результат - /site/person
 */

/*101 Опциональные параметры
>В path параметры могут быть опциональными:
<Route path="/people/:id" ... />
>Приложение дожно позволять перезагружать страницы, или передавать URL другим пользователям.
>Адрес должен содержать ID открытого элемента (тогда открывв URL пользователь попадет на тот-же "экран").
 */

/*102 Авторизация и закрытые страницы
Можно использовать компонент Redirect, чтобы переслать пользователя на логин-страницу:
<Redirect to="/login" />
Система авторизации, которую мы рассмотрели, не обеспечивает безопасность в приложении (проверка прав должна проводиться на сервере).
 */

/*103 Switch (обработка несуществующих адресов)
Компонент Switch оборачивает другие компоненты (Route и Redirect)
<Switch>
    <Route path="/books" ... />
    <Route path="/blog" ... />
</Switch>
>Switch отрисует только первый элемент, который соответствует адресу.
>Route без свойства path срабатывает всегда.
 */

/*Введение в Redux
>Redux решает проблему управления состоянием в приложении.
>Redux предлагает хранить state в одном "глобальном" объекте.
>Функция Reducer обновляет глобальный state в ответ на Actions (действия).
>Объект Store координирует обновления.
 */